#ifndef NANOSOFT_PROCESSMANAGER_H
#define NANOSOFT_PROCESSMANAGER_H

#include <nanosoft/object.h>
#include <nanosoft/easylib.h>
#include <nanosoft/easylist.h>

#include <string>

/**
 * Функция закрытия файловых дескрипторов
 *
 * Пользователь должен сам реализовать данную функцию в своем коде. Она будет
 * вызываться при запуске дочернего процесса. Кроме пользователя никто лучше
 * не знает как и какие файловые дескрипторы (файлы, сокеты, каналы и т.п.)
 * нужно закрывать, а какие нет.
 *
 * Данная функция вызывается только в контексте потомка
 *
 * NOTE Если вы не пользуетесь менеджером процессов и не запускаете свои
 * процессы через ProcessManager::exec() и компилятор жалуется на не найденный
 * close_on_exec(), то убедитесь что компоновщику переданна опция --gc-sections
 * (-Wl,--gc-sections при вызове через gcc). В крайнем случае, просто определите
 * эту функциию с пустым телом
 *
 * WARNING данная функция не должна запускать процедуру корректного завешения
 * процесса, она должна только закрыть все открытые файловые дескрипторы
 */
void close_on_exec();

/**
* callback обработчика завершения подпроцесса
* @param pid PID завершенного процесса
* @param exited true - если процесс завершился сам, false если был завершен по сигналу
* @param exit_code если процесс завершился сам, то это код завершения, если завершен по сигналу, то это номер сигнала
* @param data указатель на пользовательский объект
*/
typedef void (*exit_callback_t)(pid_t pid, bool exited, int exit_code, ptr<Object> data);

/**
 * Описание процесса
 */
class ProcessInfo: public Object
{
public:
	
	/**
	 * PID процесса
	 */
	pid_t pid;
	
	/**
	 * Функция обратного вызова
	 *
	 * Вызывается когда завершается процесс
	 */
	exit_callback_t callback;
	
	/**
	 * Пользовательские данные
	 *
	 * Передаются в функцию обратного вызова
	 */
	ptr<Object> data;
	
};

/**
 * Карта отслеживаемых процессов
 */
typedef std::map<pid_t, ptr<ProcessInfo> > process_list_t;

/**
 * Менеджер процессов
 *
 * Менеджер процессов позволяет отслеживать завершение процессов и предотвращать
 * появление зомби-процессов. В Linux дочерний процесс после завершения
 * переходит в состояние зомби до тех пор пока родительский процесс не вызовет
 * функцию wait() для него, чтобы получить код завершения процесса. Если не
 * делать этого, то дочерние процессы будут висеть сколь угодно долго и занимать
 * при этом ресурсы.
 *
 * Также данный менеджер позволяет отслеживать завершение стороннего процесса,
 * но не может получить его код возврата.
 *
 * Менеджер процессов должен существовать в единичном экземпляре.
 */
class ProcessManager
{
private:
	
	/**
	 * Карта процессов
	 */
	process_list_t ps;
	
public:
	
	/**
	 * Форкнуть процесс и включить потомка под контроль
	 * Функция callback будет автоматически вызвана при его завершении
	 * data — указатель на пользовательские данные
	 */
	pid_t fork(exit_callback_t callback, ptr<Object> data);
	
	/**
	 * Запустить внешний процесс и добавить его в отслеживание
	 * Функция callback будет автоматически вызвана при его завершении
	 * data — указатель на пользовательские данные
	 */
	pid_t exec(std::string path, const EasyList &args, const EasyRow & env, exit_callback_t callback, ptr<Object> data);
	
	/**
	 * Добавить существующий процесс в мониторинг
	 * Функция callback будет автоматически вызвана при его завершении
	 * data — указатель на пользовательские данные
	 */
	void bindProcess(pid_t pid, exit_callback_t callback, ptr<Object> data);
	
	/**
	 * Таймер
	 *
	 * Проводит проверки и считывает статусы завешенных процессов
	 */
	void onProcessTimer();

	/**
	 * Тщательно проверить существование процесса
	 */
	bool processExists(pid_t pid, std::string command);
};

#endif // NANOSOFT_PROCESSMANAGER_H
