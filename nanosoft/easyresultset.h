#ifndef NANOSOFT_EASYRESULTSET_H
#define NANOSOFT_EASYRESULTSET_H

#include <nanosoft/easyrow.h>

#include <vector>

/**
 * Простой набор данных
 *
 * Класс EasyResultSet предоставляет семантику набора данных (таблицы) БД.
 *
 * По сути данный класс является списком элементов EasyRow (vector<EasyRow>),
 * который в разных частях библиотеки может выполнять разные функции.
 * Первичное назначение - представлять набор данных (строк) которые возвращает
 * SQL-запрос. Но это также может быть просто набор данных для классов
 * QListView, QTreeView, QTableView или что-то еще.
 *
 * @NOTE Класс использует семантику умных указателей. По логике реализации
 * он является указателем на автоматически создаваемый объект.
 * Когда один объект копирует другого, оба объекта начинают ссылаться
 * на одни и те же реальные данные и оба могут модифицировать данные.
 */
class EasyResultSet
{
private:
	
	/**
	 * Собственно объект хранящий данные
	 */
	class ResultSet: public Object, public std::vector<EasyRow>
	{
	};
	
	/**
	 * Указатель с подсчетом ссылок
	 */
	ptr<ResultSet> ref;
	
public:
	
	/**
	 * Претворяемся что мы vector<>
	 *
	 * Реализовано для совместимости с STL, но использовать не рекомендуется
	 */
	typedef ResultSet::const_iterator const_iterator;
	
	/**
	 * Конструктор по умолчанию
	 *
	 * Создает пустой набор данных
	 */
	EasyResultSet();
	
	/**
	 * Конструктор
	 *
	 * Пустой набор данных на size строк (кортежей).
	 */
	EasyResultSet(int size);
	
	/**
	 * Конструктор копий
	 *
	 * Копирует ссылку на реальный объект, в результате оба объекта ссылаются
	 * на один реальный набор данных
	 */
	EasyResultSet(const EasyResultSet &r);
	
	/**
	 * Деструктор
	 *
	 * Осовобождает ссылку. Если на объект никто не ссылается
	 * то он удаляется. Если ссылки еще есть, то продолжает жить.
	 */
	~EasyResultSet();
	
	/**
	 * Претворяемся что мы vector<>
	 *
	 * Реализовано для совместимости с STL, но использовать не рекомендуется
	 */
	inline const_iterator begin() const { return ref->begin(); }
	
	/**
	 * Претворяемся что мы vector<>
	 *
	 * Реализовано для совместимости с STL, но использовать не рекомендуется
	 */
	inline const_iterator end() const { return ref->end(); }
	
	/**
	 * Оператор копий
	 *
	 * Старый набор высвобождается, копирует ссылку на объект, в результате
	 * оба объекта ссылаются на один набор данных.
	 */
	EasyResultSet& operator = (const EasyResultSet &row) { ref = row.ref; return *this; }
	
	/**
	 * Число строк в наборе
	 *
	 * count() как-то логичнее и привычнее чем size()
	 */
	inline int count() { return ref->size(); }
	
	/**
	 * Число строк в наборе
	 *
	 * для симметрии с vector<>
	 */
	inline int size() { return ref->size(); }
	
	/**
	 * Установить размер набора данных (число строк)
	 */
	void resize(int size);
	
	/**
	 * Очистить набор данных
	 *
	 * Действие функции clear() оказывает на всех кто имеет ссылку на объект,
	 * т.е. удаляются сами данные.
	 */
	void clear();
	
	/**
	 * Сбросить список
	 *
	 * В отличие от функции clear() данные не очищаются, а сбрасывается только
	 * указатель и создается новый чистый объект, таким образом данная функция
	 * не оказывает влияния на других пользователей ссылающихся на данные.
	 * Если на старые данные никто не ссылается, то они осовбождаются.
	 */
	void reset();
	
	/**
	 * Претворяемся что мы vector<>
	 */
	EasyRow operator [] (int idx);
	
	/**
	 * Вернуть строку по индексу
	 *
	 * Проверка на выход за границы не выполняется.
	 */
	EasyRow get(int pos) const;
	
	/**
	 * Установить строку по индексу
	 *
	 * Проверка на выход за границы не выполняется.
	 *
	 * NOTE копируется ссылка на объект, если нужно создать независимую копию
	 * объекта, то создайте независимую копию с помощью EasyRow::copy()
	 */
	void set(int pos, EasyRow row);
	
};

#endif // NANOSOFT_EASYRESULTSET_H
